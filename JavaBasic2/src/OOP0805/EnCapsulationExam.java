package OOP0805;

public class EnCapsulationExam {

	public static void main(String[] args) {
		// 캡슐화
		// -> 관련된 데이터, 기능을 하나의 캡슐로 묶음
		// -> 외부의 직접적인 접근으로부터 내부 데이터를 보호하는
		// -> 객체지향의 핵심 원칙 중 하나
		// --> 정보 은닉 !!! (개발자한테는 보이게)
		// --> 접근 제어 !!!
		
		// 캡슐화에 필요한 것
		// 1. 데이터 숨기기 (접근 제어자)
		// 2. 안전한 통로 제공 (데이터 접근 기준 만들기)
		
		
		// -- 접근 제어자 --
		// -> 객체지향 캡슐화를 구현하기 위해 자바에서 제공하는 키워드
		// 1. private 
		// - 접근 범위: 해당 클래스 내부
		//  	quiz. private을 클래스에 쓰는게 가능할까?
		//  	answer. 가능해도 쓰지 말 것, 고립될 수 있음
		// - 현업에서는 엔티티, dto의 멤버변수에 private 형태로 선언 후
		//   멤버변수로 접근하는 장치를 따로 마련
		//   - getter / setter
		
		// 접근 제어자를 통해 멤버 변수로의 다이렉트 접근은 차단된 상태
		// 아는 사람만 접근이 가능하도록 처리함
		Capsule c1 = new Capsule();
		c1.setTest1("문자");
		
		// 2. default - 접근 제어자에 아무것도 없으면 default 상태인 것 (기본 제공)
		// - 접근 범위: 해당 패키지
		
		// 3. protected
		// - 접근 범위: 해당 패키지
		// - 상속 받았다면 다른 패키지도 접근 가능 (import로 패키지 명명해주고 써야함)
		// - 그래서 보통 protected가 있으면 상속 받았다고 여기기도 함
		
		// 4. public
		// - 접근 범위: 해당 프로젝트
		
		
		// << 빌더 패턴 사용법 >> (setter 대체)
//		Capsule c2 = Capsule.builder()
//				.test1("문자")
//				.test2(1123)
//				.test3(21342);
		
		
		
		
		// -----캡슐화 정리-----
		// 1. Setter는 신중한 사용을 요구함
		// 2. 현업 가면 final 키워드를 더 자주 보게 될 것
		//    -> 불변 객체 설계
		// 3. 접근 제어자의 선택 기준을 더 확실하게 설계
		//    -> 조금이라도 의심스러우면 더 제한적으로 할 것(private 남용하지는 말고)
		
		// 결론 :: 캡슐화는 객체 지향의 설계 핵심 원칙
	}

}
