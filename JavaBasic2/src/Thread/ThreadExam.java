package Thread;

public class ThreadExam {

	// 스레드 : 작업을 수행하는 개별적 실행 흐름
	// -> 병렬 작업을 진행하려고 사용하는 것
	
	// !주의점 : 동시성 문제
	//  -- 프로그래밍에서 여러 작업이나 프로세스가 동시에 실행될 때 발생할 수 있는 문제
	//  -- 공유 자원에 여러 스레드, 프로세스가 동시에 접근 수정하려할때
	//  -- 시스템상 문제가 일어날 수 있음
	
	// 동시성 문제의 주 원인 
	// 1) 공유 자원 접근 - 트랜잭션이 필요한 이유
	// 2) 레이스 컨디션(경쟁상태) : 두개 이상의 스레드가 자원에 접근하는 순서에 따라 결과가 달라질 때
	// 3) 데드락(deadlock)/교착상태 : 두개 이상의 스레드가 자원을 기다리며 멈춰버린 상태 
	// 4) 라이브락(Livelock) : 스레드들이 상태를 변경하면서도(양보) 작업을 진행하지 못하는 상태
	// 5) 자원 고갈 : 특정 스레드가 필요한 자원을 지속적으로 얻지 못해서 작업을 완료하지 못하는 경우
	//    - 우선순위가 낮은 작업이 계속해서 배제되는 상황이 될 수 있음
	
	// 동시성 문제의 해결방안
	// -> 비동기 프로그래밍
	
	
	// 스레드가 필요한 이유
	// 상황: 와플곰의 가게가 대박이 났습니다! 하지만 직원은 와플곰 혼자뿐입니다.
//		손님 A: "주문할게요!"
//		와플곰: "네, 잠시만요! (주문받는 중...)"
//		손님 B: "저기요, 와플은 언제 나와요?"
//		와플곰: "죄송합니다! 주문 먼저 받고 만들어 드릴게요!"
//		손님 C: "계산해 주세요!"
//		와플곰: "으악! 몸이 열 개라도 부족해!"
	
	// 멀티스레딩 : 와플곰(스레드)의 고충을 해결하기 위해 
	// 			가게(프로그램)안에 여러명의 일꾼(스레드)를 두는 개념
	
	// 프로세스 : 운영체제에서 실행 중인 하나의 프로그램
	// - 프로세스 간 자원 공유는 하지 않음
	// 스레드 : 프로세스 내부에서 작업을 수행하는 개별 흐름
	// - 프로세스 내부의 것이기 때문에 프로세스 자원을 이용
	// 결론 : 프로세스보다 스레드를 생성하는게 당연히 더 효율적이지
	
	
	// 멀티프로세스, 멀티스레드 : 
	
	// 스레드 생성
	// 1. Thread 클래스 상속
	// 2. Runnable 인터페이스 구현
	// 3. 람다 기반 스레드 생성

	
	public static void main(String[] args) {
		
		RunnerCat hurryCat = new RunnerCat("급하냥");
		RunnerCat tango = new RunnerCat("탱고");
		
		
		// 멀티 스레딩을 구현하려면 start를 호출해야함
		// 스레드는 일을 분할 시키는 것이 목적
		
		hurryCat.run();
		tango.run();
		
//		hurryCat.start(); // 동시 진행
//		tango.start(); // 동시 진행
	}
	
	
}

// 1
// ex. 달리기만 전문적으로 할 수 있는 달리기 전문 급하냥
class RunnerCat extends Thread {
	private String name;
	public RunnerCat(String name) {this.name=name;}
	
	// 메서드 내부에 해당 스레드가 수행할 작업을 정의
	@Override
	public void run() {
		for(int i=1; i<3; i++) {
			System.out.println(name+"이(가) "+i+"km 지점을 통과");
			try {
				Thread.sleep(1000);
			} catch(InterruptedException e) {
				e.printStackTrace();
			}
		}
		System.out.println(name+" 완주!");
	}
	
}